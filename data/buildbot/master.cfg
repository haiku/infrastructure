# -*- python -*-
# ex: set syntax=python:

# BuildBot code for Haiku.
# DO NOT PUT PASSWORDS IN ME. Use util.Secret!

### IMPORTS
import os
import cgi
import stat
import string
from textwrap import dedent

## Buildbot specific
from buildbot.worker import Worker
from buildbot.worker.libvirt import LibVirtWorker, Connection
from buildbot.changes.filter import ChangeFilter
from buildbot.changes.gitpoller import GitPoller
from buildbot.changes.pb import PBChangeSource
from buildbot.config import BuilderConfig
from buildbot.interfaces import WorkerTooOldError
from buildbot.process.builder import enforceChosenWorker
from buildbot.process.remotecommand import (LoggedRemoteCommand, RemoteShellCommand)
from buildbot.process.factory import BuildFactory
from buildbot.process.properties import (Interpolate, Property, renderer, WithProperties)
from buildbot.plugins import secrets, util

from buildbot.schedulers import basic, forcesched, timed, triggerable
from buildbot.reporters import irc,mail
from buildbot.status.builder import SKIPPED
from buildbot.www import auth, authz
from buildbot.steps.trigger import Trigger
from buildbot.steps import master, shell, worker
from buildbot.steps.shell import Compile, Configure, ShellCommand
from buildbot.steps.worker import MakeDirectory, RemoveDirectory
from buildbot.steps.source.git import Git
from buildbot.steps.transfer import StringDownload

###############################################################################
### GENERAL CONFIGURATION
###############################################################################
#
c = BuildmasterConfig = {}

# Secrets file to keep passwords out of master.cfg
c['secretsProviders'] = [secrets.SecretInAFile(dirname=os.path.join(basedir, "secrets"))]

####### Project and Ports
#
c['projectName'] = "Haiku"
c['projectURL'] = 'http://www.haiku-os.org'
c['buildbotURL'] = 'https://build.haiku-os.org/buildbot/'
c['protocols'] = {"pb": {"port": 9989}}
c['buildbotNetUsageData'] = None

####### Database
c['db_url'] = "sqlite:///state.sqlite"

####### Logging
c['logCompressionLimit'] = 16384
c['logCompressionMethod'] = 'bz2'
c['logMaxSize'] = 20*1024*1024
c['logMaxTailSize'] = 32768

####### Data Lifetime
c['changeHorizon'] = 200
#c['buildHorizon'] = 100
#c['eventHorizon'] = 50
#c['logHorizon'] = 50
#USM 2015-04-21 change this to 80 so we retain more logs
#c['logHorizon'] = 80

####### Caches
c['caches'] = {
	'Changes' : 1000,
	'Builds' : 50,
	'chdicts' : 1000,
	'BuildRequests' : 10,
	'SourceStamps' : 20,
	'ssdicts' : 20,
	'objectids' : 10,
	'usdicts' : 100,
}

###############################################################################
### WORKER DEFINITIONS
###############################################################################
#
# Worker requirements (basically Haiku's build requirements):
#	autoconf, automake, bison, curl-devel, flex, gawk, gcc, makeinfo, mkisofs,
#	nasm, wget
#
# Additional requirements for workers doing the host part of a bootstrap build:
#	cmake, ncurses-devel (for 'tic')
#
"""
PROPERTIES
'configureArgs' :	<list-of-strings> to pass to Haiku's configure.
					Host specific options only.
'downloadDirCacheTimeInDays':	<number> of days after which a file in the
					download directory shall be flushed. The default value of
					7 will remove all files older than 7 days. A value of 0
					clears the download directory for every build.
'jobs' :			<number> of jobs (as part of one build) to run concurrently
					on the worker. The default is 1.
'moveImageCommand': <shell-command-with-1-arg> which will be invoked to move
					the created image to the place from where it can be run as
					VM. The parameter will be expanded by the name of the
					generated haiku image file. This property is only used by
					the builder that implements the host-part of a haikuports
					or bootstrap build.
'workerHaikuArch':	<haikuArch> that this Haiku worker is running on. Only builds
					for the same architecture will be run on that worker.
"""

allWorkers = []


#######################################
## Debian Linux, 64-bit, use-xattr-ref, reiserfs
allWorkers.append(
	Worker(
		'arfonzo-bot1-debian',
		util.Secret('builder-arfonzo'),
		properties = {
			'host_os' : 'debian',
			'host_arch' : 'x86_64',
			#'configureArgs' : [ '--use-xattr-ref' ],
			'downloadCacheTimeInDays' : 0,
			'jobs' : 16,
			'can_build' : ['haiku-master', 'repo', 'nightly'],
		},
		notify_on_missing = 'art@poorcoding.com',
		max_builds = 1))

########################################
### Haiku gcc2, jessicah
#allWorkers.append(
#	Worker(
#		'chisana-bot-haiku',
#		util.Secret('builder-jessicah'),
#		properties = {
#			'configureArgs' : [ ],
#			'jobs' : 1,
#			'workerHaikuArch' : 'x86_gcc2_hybrid',
#		},
#		max_builds = 1))

## ubuntu-14.04, 64-bit, xattr-ref, ext4fs
allWorkers.append(
	Worker(
		'geist-bot1-ubuntu64',
		util.Secret("builder-geist"),
		properties = {
			'host_os' : 'ubuntu',
			'host_arch' : 'x86_64',
			#'configureArgs' : [ '--use-xattr-ref' ],
			'downloadCacheTimeInDays' : 7,
			'jobs' : 2,
			'can_build' : ['haiku-master', 'repo'],
		},
		max_builds = 1))

#######################################
## ubuntu-14.04, 64-bit, xattr-ref, ext4fs
allWorkers.append(
	Worker(
		'geist-bot2-ubuntu64',
		util.Secret("builder-geist"),
		properties = {
			'host_os' : 'ubuntu',
			'host_arch' : 'x86_64',
			#'configureArgs' : [ '--use-xattr-ref' ],
			'downloadCacheTimeInDays' : 7,
			'can_build' : ['haiku-master', 'repo'],
			'jobs' : 2,
		},
		max_builds = 1))

#######################################
## ubuntu-14.04, 64-bit, xattr-ref, ext4fs
allWorkers.append(
	Worker(
		'geist-bot3-ubuntu64',
		util.Secret("builder-geist"),
		properties = {
			'host_os' : 'ubuntu',
			'host_arch' : 'x86_64',
			#'configureArgs' : [ '--use-xattr-ref' ],
			'downloadCacheTimeInDays' : 7,
			'can_build' : ['haiku-master', 'nightly'],
			'jobs' : 2,
		},
		max_builds = 1))

#######################################
## ubuntu-14.04, 64-bit, xattr-ref, ext4fs
allWorkers.append(
	Worker(
		'geist-bot4-ubuntu64',
		util.Secret("builder-geist"),
		properties = {
			'host_os' : 'ubuntu',
			'host_arch' : 'x86_64',
			#'configureArgs' : [ '--use-xattr-ref' ],
			'downloadCacheTimeInDays' : 7,
			'can_build' : ['haiku-master', 'nightly'],
			'jobs' : 2,
		},
		max_builds = 1))

#######################################
## Fedora 21, x86_64, MacMini
allWorkers.append(
	Worker(
		'kallisti5-fedora01',
		util.Secret("builder-kallisti5"),
		properties = {
			'host_os' : 'fedora',
			'host_arch' : 'x86_64',
			#'configureArgs' : [ '--use-xattr-ref' ],
			'downloadCacheTimeInDays' : 7,
			'can_build' : ['haiku-master', 'repo', 'nightly'],
			'jobs' : 2,
		},
		notify_on_missing = 'kallisti5@unixzen.com',
		max_builds = 1))

#######################################
## Fedora 21, x86_64, MacMini
allWorkers.append(
	Worker(
		'kallisti5-fedora02',
		util.Secret("builder-kallisti5"),
		properties = {
			'host_os' : 'fedora',
			'host_arch' : 'x86_64',
			#'configureArgs' : [ '--use-xattr-ref' ],
			'downloadCacheTimeInDays' : 7,
			'can_build' : ['haiku-master', 'repo', 'nightly'],
			'jobs' : 2,
		},
		notify_on_missing = 'kallisti5@unixzen.com',
		max_builds = 1))

#######################################
## xubuntu, 64-bit, xattr-ref, ext4fs
allWorkers.append(
	Worker(
		'luroh-bot1-xubuntu64',
		util.Secret("builder-luroh"),
		properties = {
			'host_os' : 'ubuntu',
			'host_arch' : 'x86_64',
			#'configureArgs' : [ '--use-xattr-ref' ],
			'downloadCacheTimeInDays' : 7,
			'can_build' : ['haiku-master', 'repo', 'nightly'],
			'jobs' : 1,
		},
		max_builds = 1))

#######################################
## Linux Mint 17.3, 64-bit, no-xattr
#allWorkers.append(
#	Worker(
#		'umccullough-bot1-mint64',
#		util.Secret("builder-umccullough"),
#		properties = {
#			'configureArgs' : [ '--use-xattr-ref' ],
#			'jobs' : 2,
#		},
#		max_builds = 1))
#
########################################
### Linux Mint 17.3, 64-bit, no-xattr
#allWorkers.append(
#	Worker(
#		'umccullough-bot2-mint64',
#		util.Secret("builder-umccullough"),
#		properties = {
#		'configureArgs' : [ '--use-xattr-ref' ],
#			'jobs' : 2,
#		},
#		max_builds = 1))
#
#
########################################
### Linux Mint 17.3, 64-bit, no-xattr
#allWorkers.append(
#	Worker(
#		'umccullough-bot3-mint64',
#		util.Secret("builder-umccullough"),
#		properties = {
#			'configureArgs' : [ '--use-xattr-ref' ],
#			'jobs' : 2,
#		},
#		max_builds = 1))

c['workers'] = allWorkers

#######################################
# collect all workers in a dict for easy lookup
workersByName = {}
for worker in allWorkers:
	workersByName[worker.workername] = worker

#######################################
# The list of workers to use for building Haiku on Haiku.
nativeHaikuWorkerNames = [
	name for name in (
#		'chisana-bot-haiku',
	) if name in workersByName
]

###############################################################################
### ARCHITECTURE DEFINITIONS
###############################################################################
#
# This defines the list of architectures. For each of these, a separate set of
# buildtools (cross-tools) will be built. Please keep this in decreasing order
# of importance, as the builders will follow this order.
targetArchitectures = [
#	'x86',
	'x86_gcc2',
	'x86_64',
	'arm',
	'ppc',
	'm68k',
]

# Defines the hybrid architectures and their respective list of target
# architectues.
hybridArchitectures = {
#	'x86_hybrid' : [ 'x86', 'x86_gcc2' ],
	'x86_gcc2_hybrid' : [ 'x86_gcc2', 'x86' ],
}

# All architectures for which Haiku can be built, includes the hybrids.
haikuArchitectures = targetArchitectures + hybridArchitectures.keys()

# Defines the machine triples corresponding to each basic architecture
machineTriples = {
	'arm' : 'arm-unknown-haiku',
	'm68k' : 'm68k-unknown-haiku',
	'ppc' : 'powerpc-apple-haiku',
	'x86' : 'i586-pc-haiku',
	'x86_64' : 'x86_64-unknown-haiku',
	'x86_gcc2' : 'i586-pc-haiku',
}

###############################################################################
### JAM TARGET DEFINITIONS
###############################################################################
#
x86JamTargets = [
	'@minimum-raw',
	'@release-raw build <repository>Haiku',
	'-sHAIKU_DONT_REBUILD_PACKAGES=1 @release-raw',
	'-sHAIKU_DONT_REBUILD_PACKAGES=1 @release-vmware',
	'-sHAIKU_DONT_REBUILD_PACKAGES=1 haiku-boot-floppy',
	'-sHAIKU_DONT_REBUILD_PACKAGES=1 @release-anyboot',
	'-sHAIKU_DONT_REBUILD_PACKAGES=1 @release-cd',
	'-sHAIKU_DONT_REBUILD_PACKAGES=1 -sTARGET_BOOT_PLATFORM=pxe_ia32 '
		+ 'pxehaiku-loader haiku-netboot-archive',
	'-sHAIKU_DONT_REBUILD_PACKAGES=1 unittests',
]

jamTargets = {
	'arm' : [
		'@minimum-mmc',
	],
	'm68k' : [
		'haiku-image',
		'haiku-boot-floppy',
		'haiku.prg',
	],
	'ppc' : [
		'@minimum-raw',
		'haiku-boot-cd-ppc',
	],
	'x86_64' : x86JamTargets,
	'x86_gcc2' : x86JamTargets,
	'x86_gcc2_hybrid' : x86JamTargets,
}

x86JamDebugTargets = [
	'-sDEBUG=1 @minimum-raw',
	'-sDEBUG=1 @release-raw build <repository>Haiku',
	'-sDEBUG=1 -sHAIKU_DONT_REBUILD_PACKAGES=1 @nightly-raw',
	'-sDEBUG=1 @release-raw',
	'-sDEBUG=1 -sTARGET_BOOT_PLATFORM=pxe_ia32 pxehaiku-loader haiku-netboot-archive',
]

nativeJamTargets = [
	'@minimum-raw',
	'@release-raw build <repository>Haiku',
	'-sHAIKU_DONT_REBUILD_PACKAGES=1 @release-raw',
]

repositoriesJamTargets = {
	'x86_64' : [
		'@release-raw build <repository>Haiku',
	],
	'x86_gcc2_hybrid' : [
		'@release-raw build <repository>Haiku',
	],
}

jamTargetsForNightlies = [
	'@nightly-raw build <repository>Haiku',
	'-sHAIKU_DONT_REBUILD_PACKAGES=1 @nightly-anyboot',
	'-sHAIKU_DONT_REBUILD_PACKAGES=1 @nightly-raw',
]

nightliesJamTargets = {
	'x86_64' : jamTargetsForNightlies,
	'x86_gcc2_hybrid' : jamTargetsForNightlies,
#	'ppc' : jamTargetsForNightlies,
	'arm' : [
		'@minimum-mmc'
	],
}

jamDebugTargets = {
	'arm' : [
		'-sDEBUG=1 @minimum-mmc',
	],
	'm68k' : [
		'-sDEBUG=1 haiku-image',
	],
	'ppc' : [
		'-sDEBUG=1 @minimum-raw',
		'-sDEBUG=1 haiku-boot-cd-ppc',
	],
	'x86_64' : x86JamDebugTargets,
	'x86_gcc2' : x86JamDebugTargets,
	'x86_gcc2_hybrid' : x86JamDebugTargets,
}

###############################################################################
### BOOTSTRAP DEFINITIONS
###############################################################################
#
# Defines the configurations for which bootstrap builds should be done and the
# time spec on which those are due.
bootstraps = [
	{
		'haikuArch' : 'x86_64',
		# 'haikuBranch' : 'master',
		'haikuBranch' : 'bootstrap-test',
		'haikuportsBranch' : 'testing_x86_64',
		'dayOfWeek' : '1',
		'hour' : '10',
	},
]

###############################################################################
### HAIKUPORTS DEFINITIONS
###############################################################################
#
# Defines the configurations for which haikuports package tree builds should be
# done.
haikuports = [
	{
		'branch' : 'testing_x86_64',
		'haikuArch' : 'x86_64',
		'haikuBranch' : 'master',
	},
]

###############################################################################
### REPOSITORIES
###############################################################################
#
allRepositories = {
	'haiku' : r'https://git.haiku-os.org/haiku.git',
	'buildtools': r'https://git.haiku-os.org/buildtools.git',
	'haikuports': r'https://bitbucket.org/haikuports/haikuports.git',
	'haikuports.cross': r'https://bitbucket.org/haikuports/haikuports.cross.git',
	'haikuporter': r'https://bitbucket.org/haikuports/haikuporter.git',
}

###############################################################################
### GEOLOCATION SERVICE KEY
###############################################################################
#
DefaultGeolocationServiceKeyHeaderContent = Interpolate(
	"#define DEFAULT_GEOLOCATION_SERVICE_KEY \"%(secret:mozilla-geokey)s\""
)

###############################################################################
### WWW CONFIGURATION
###############################################################################
#

c['www'] = []

# Web UI
c['www'] = {
	'port': 80,
	'plugins': {'waterfall_view': True},
#	'auth': util.HTPasswdAuth("htpasswd"),
#	'auth': util.UserPasswordAuth({"admin": "likeiwouldusethisaccount"}),
	'authz': util.Authz(
		allowRules=[
			util.AnyControlEndpointMatcher(role="admins"),
		],
		roleMatchers=[
			util.RolesFromUsername(roles=["admins"], usernames=["admin"]),
		]
	)
#	'changecommentlink': (r'#(\d+)',
#		 r'https://dev.haiku-os.org/ticket/\1',
#		 r'Ticket \g<0>')
}

###############################################################################
### STATUS CONFIGURATION
###############################################################################
#
c['services'] = []

# IRC bot
#c['services'].append(
#	irc.IRC(
#		host = 'irc.freenode.net',
#		nick = 'HAIKU-Buildbot',
#		password = util.Secret("bot-irc"),
#		allowForce = False,
#		channels = [ 'haiku', 'haiku-dev' ],
#		notify_events = {
#			'exception': 1,
#			'successToFailure': 1,
#			'failureToSuccess': 1,
#		}))

# TODO: FIX
## e-mail sender
#c['services'].append(
#	mail.MailNotifier(
#		fromaddr = 'buildbot@haiku-os.org',
#		sendToInterestedUsers = False,
#		buildSetSummary = True,
#		mode = ('change'),
#		categories = [ 'haiku.master', 'buildtools.master' ],
#		extraRecipients = [ 'haiku-commits@freelists.org' ]))

###############################################################################
## UPLOAD PARAMETERS
###############################################################################
#
# stuff required for uploading of repositories and images
uploadServer = 'baron.haiku-os.org'
uploadMasterRepoDestPath = 'files/haiku-repositories/master'
uploadNightliesDestPath = 'files/nightly-images'
uploadCatkeysDestPath = 'files/catalogs'

###############################################################################
## OPTIONAL CDN PARAMETERS
###############################################################################
# to disable, set values to ''
# XXX: Not used yet. See https://community.keycdn.com/t/multiple-ssh-keys-for-rsync/244/4
# Using the same private keys across multiple builders at remote locations is
# asking for trouble.
cdnUser = ''
cdnServer = ''
cdnNightliesDestPath = ''

#cdnUser = 'haikuinc'
#cdnServer = 'rsync.keycdn.com'
#cdnNightliesDestPath = 'zones/nightly'

###############################################################################
### CHANGE_SOURCE
###############################################################################
#
c['change_source'] = []

# A change source listening to incoming changes triggered by git hooks in
# our repositories on git.haiku-os.org
c['change_source'].append(
	PBChangeSource(
		port = 9988,
		user = 'change.haiku',
		passwd = util.Secret("change-notify")))

# Polling haikuports for changes.
c['change_source'].append(
	GitPoller(
		workdir = 'gitpoller-haikuports',
		branches = [ 'testing_x86_64' ],
		repourl = allRepositories['haikuports'],
		project = 'haikuports',
		pollinterval = 300))

###############################################################################
### BUILDBOT EXTENSIONS
###############################################################################
#
# A slight variation on FileExists as suggested by Tom Prince here:
# https://gist.github.com/tomprince/1608839
class PathIsMissing(object):
	"""
	Check for the existence of a path on the worker.
	"""
	def __init__(self, path):
		self.path = path
	def __call__(self, step):
		workerver = step.workerVersion('stat')
		if not workerver:
			raise WorkerTooOldError("worker is too old, does not know "
					"about stat")

		def commandComplete(cmd):
			return cmd.rc != 0

		cmd = LoggedRemoteCommand('stat', {'file': str(self.path) })
		d = step.runCommand(cmd)
		d.addCallback(lambda res: commandComplete(cmd))
		return d

# Determines if two given files are different on the worker.
class FilesAreDifferent(object):
	"""
	Checks if two files are different.
	"""
	def __init__(self, file1, file2):
		self.file1 = file1
		self.file2 = file2
	def __call__(self, step):
		file1 = str(self.file1)
		file2 = str(self.file2)
		cmd = RemoteShellCommand(step.workdir, 'cmp %s %s' %(file1, file2))
		d = step.runCommand(cmd)
		def evaluate(cmd):
			return cmd.rc != 0
		d.addCallback(lambda _: evaluate(cmd))
		return d

def workersForTask(pool, taskName):
	"""
	Finds workers for the described task.
	"""
	candidates = []
	for worker in pool:
		if "can_build" not in worker.properties:
			continue
		if taskName in worker.properties["can_build"]:
			candidates.append(worker.workername)
	print("Found",len(candidates),"workers for",taskName)
	return candidates

###############################################################################
### RENDERERS
###############################################################################
#
# render the command for building the cross tools
@renderer
def renderBuildCrossToolsCommand(props):
	command = [ '../haiku/configure' ]

	targetArch = props.getProperty('targetArch')

	jobs = props.getProperty('jobs')
	if jobs and targetArch != 'x86_gcc2':
		command.append('-j' + str(jobs))

	command += [ '--build-cross-tools', targetArch, '../buildtools' ]
	return command

# render the command for configuring the haiku build
@renderer
def renderConfigureBuildCommand(props):
	command = [
		'../../haiku/configure',
		'--use-gcc-pipe'
	]

	# activate official distro compatibility for gcc2-hybrids only, to indicate
	# that only these are "supported" builds
	if props.getProperty('haikuArch') == 'x86_gcc2_hybrid' or props.getProperty('haikuArch') == 'x86_64':
		command += [ '--distro-compatibility', 'official' ]

	command += props.getProperty('configureArgs', [])

	jobs = props.getProperty('jobs')
	if jobs:
		command.append('-j' + str(jobs))

	targetArchs = props.getProperty('targetArchs')
	nativeBuild = props.getProperty('nativeBuild')
	for targetArch in targetArchs:
		if nativeBuild:
			command += [ '--target-arch', targetArch ]
		else:
			machineTriple = machineTriples[targetArch]
			prefix = '../../cross-tools-%s/cross-tools-%s/bin/%s-' \
				% (targetArch, targetArch, machineTriple)
			command += [ '--cross-tools-prefix', prefix ]

	configureForBootstrap = props.getProperty('configureForBootstrap')
	if configureForBootstrap:
		buildDir = props.getProperty('builddir')
		command += [
			'--bootstrap',
			'%s/../haikuporter/haikuporter' % buildDir,
			'%s/../haikuports.cross' % buildDir,
			'%s/../haikuports' % buildDir
		]

	props.setProperty('configureCommand', ' '.join(command),
					  'renderConfigureCommand')

	return command


# render the command for installing jam
@renderer
def renderInstallJamCommand(props):
	workerBinDir = props.getProperty('workerBinDir')

	return dedent(r"""
		mkdir -p "%s"
		cp bin.*/jam "%s/"
	"""[1:]) % (workerBinDir, workerBinDir)

# render the command for running jam
@renderer
def renderJamCommand(props):
	command = [ 'jam', '-q' ]

	jobs = props.getProperty('jobs')
	if jobs:
		command.append('-j' + str(jobs))

	target = props.getProperty('jamTarget')
	command += target.split()

	props.setProperty('jamCommand', ' '.join(command), 'renderJamCommand')

	return command

# render the shell environment used for jam
@renderer
def renderJamEnvironment(props):
	environment = {
		'HAIKU_CONTINUOUS_INTEGRATION_BUILD' : '1',
	}

	# All builders of a worker shall use the same HAIKU_DOWNLOAD_DIR.
	downloadDir = props.getProperty('downloadDir')
	if downloadDir:
		environment['HAIKU_DOWNLOAD_DIR'] = downloadDir

	# Let haikuporter use as many jobs as the specified for the worker.
	jobs = props.getProperty('jobs')
	if jobs:
		environment['HAIKU_PORTER_CONCURRENT_JOBS'] = str(jobs)

	# Add bin directory underneath the worker basedir to the PATH (for jam).
	workerBinDir = props.getProperty('workerBinDir')
	environment['PATH'] = workerBinDir + ':' + os.environ['PATH']

	return environment

# render the command for starting the target VM corresponding to the current
# build
@renderer
def renderStartTargetVmCommand(props):
	# return the command as specified for the current (host) worker
	return props.getProperty('startTargetVmCommand') % {
		'haikuImageName' : props.getProperty('haikuImageName'),
		'targetWorkerName' : props.getProperty('targetWorkerName'),
	}

# render the command for doing a bootstrap build with haikuporter
@renderer
def renderHaikuportsDoBootstrapCommand(props):
	command = [ 'haikuporter', '--do-bootstrap' ]

	jobs = props.getProperty('jobs')
	if jobs:
		command.append('-j' + str(jobs))

	return command

# render the shell command that removes everything from the download dir that
# exceeds a certain age
@renderer
def renderSetupDownloadDirCommand(props):
	downloadDir = props.getProperty('builddir') + '/../download'
	props.setProperty('downloadDir', downloadDir, 'setupDownloadDir')
	downloadDirCacheTimeInDays = props.getProperty('downloadDirCacheTimeInDays',
												   default = 7)
	return dedent(r"""
		mkdir -p "%s"
		find "%s" -type f -a ! -ctime -%s \
			-exec echo flushing {} \; -exec rm "{}" \;
	"""[1:]) % (downloadDir, downloadDir, str(downloadDirCacheTimeInDays))

# render the shell command that uploads the nightly images
@renderer
def renderUploadNightliesCommand(props):
	haikuArch = props.getProperty('haikuArch')
	args = {
		'configureCommand' : props.getProperty('configureCommand'),
		'destPath' : uploadNightliesDestPath,
		'haikuArch' : haikuArch,
		'server' : uploadServer,
		'cdnServer' : cdnServer,
		'cdnUser' : cdnUser,
		'cdnPath' : cdnNightliesDestPath,
		'workerName' : props.getProperty('workername'),
		'testMode' : '0',
	}
	if haikuArch in ('x86_gcc2_hybrid', 'x86_64'):
		args['archiveName'] = 'haiku-nightly'
	else:
		args['archiveName'] = 'haiku_unsupported-nightly'

	# Determine our target images for nightly upload
	# TODO: Move complete target up (@xxxx-xxx)
	if haikuArch in ('x86_gcc2_hybrid', 'x86_64'):
		args['imageTargets'] = 'anyboot raw'
	elif haikuArch in ('arm'):
		args['imageTargets'] = 'mmc'
	else:
		args['imageTargets'] = 'raw'

	args['readmeIntro'] = dedent(r"""
		This image file of HAIKU is intended for development purposes only.
		For official releases, see www.haiku-os.org/get-haiku
		Please file bug reports at dev.haiku-os.org

		Build details
		-------------
		Haiku repository: @HREV@ <https://git.haiku-os.org/haiku>
		Buildtools repository: @BTREV@ <https://git.haiku-os.org/buildtools>
		Haiku architecture: %(haikuArch)s
		Configure command: %(configureCommand)s
		Jam command: @JAM@
		Host machine: %(workerName)s [@BUILD_HOST@]

	"""[1:]) % args

	command = dedent(r"""
		set -e
		cat >ReadMeIntro.md <<EOF
		%(readmeIntro)s
		EOF
		btrev=`cd ../../buildtools; git describe --tags`
		hrev=`cd ../../haiku; git describe --tags`
		buildHost=`uname -a`
		targetDir=nightly-images/%(haikuArch)s
		mkdir -p $targetDir
		for imageType in %(imageTargets)s; do
			jamCommand="jam @nightly-$imageType"

			# TODO: We don't have any release mmc targets yet
			if [ "$imageType" = "mmc" ]; then
				jamCommand="jam @minimum-$imageType"
			fi
			cat ReadMeIntro.md >ReadMe.md
			cat ../../haiku/ReadMe.md >>ReadMe.md
			sed -i -e "s,@HREV@,$hrev,g" \
				-e "s,@BTREV@,$btrev,g" \
				-e "s,@JAM@,$jamCommand,g" \
				-e "s,@BUILD_HOST@,$buildHost,g" \
				ReadMe.md
			case "$imageType" in
				anyboot)
					sourceImage=haiku-nightly-anyboot.iso
					;;
				cd)
					sourceImage=haiku-nightly.iso
					;;
				raw)
					sourceImage=haiku-nightly.image
					;;
				mmc)
					sourceImage=haiku-*.mmc
					;;
			esac
			chmod 0664 $sourceImage ReadMe.md
			archiveFile=%(archiveName)s-${hrev}-%(haikuArch)s-${imageType}.zip
			zip $targetDir/$archiveFile $sourceImage ReadMe.md
			chmod 0664 $targetDir/$archiveFile
			(cd $targetDir && openssl dgst -sha256 $archiveFile \
				>$archiveFile.sha256)
		done
		cd $targetDir/..
		find . -type d -exec chmod 0755 {} \;
		find . -type f -exec chmod 0644 {} \;

		if [ ! -z "%(cdnServer)s" ]; then
			rsync -avz --chmod=u=rwX,g=rX --rsh="ssh -o StrictHostKeyChecking=no" \
				--ignore-existing --progress \
				./%(haikuArch)s/*-anyboot.zip* %(cdnUser)s@%(cdnServer)s:%(cdnPath)s/
		fi

		if [ "%(testMode)s" = "1" ]; then
			rsync --dry-run --rsh="ssh -o StrictHostKeyChecking=no" \
				--ignore-existing --progress -rp . \
				haikufiles@%(server)s:%(destPath)s/
		else
			rsync --rsh="ssh -o StrictHostKeyChecking=no" \
				--ignore-existing --progress -rp . \
				haikufiles@%(server)s:%(destPath)s/
			ssh -o StrictHostKeyChecking=no haikufiles@%(server)s \
				"~/upload-to-cdn.sh %(haikuArch)s ${hrev}"
			ssh -o StrictHostKeyChecking=no haikufiles@%(server)s \
				"~/generate-download-pages.sh %(haikuArch)s"
		fi
	"""[1:]) % args

	return command

# render the shell command that uploads a haiku repository
@renderer
def renderUploadRepositoryCommand(props):
	haikuArch = props.getProperty('haikuArch')
	args = {
		'configureCommand' : props.getProperty('configureCommand'),
		'destPath' : uploadMasterRepoDestPath,
		'haikuArch' : haikuArch,
		'jamCommand' : props.getProperty('jamCommand'),
		'server' : uploadServer,
		'workerName' : props.getProperty('workername'),
		'targetArch' : hybridArchitectures.get(haikuArch, [ haikuArch ])[0],
		'testMode' : '0',
		'userName' : props.getProperty('uploadUser'),
	}

	args['readme'] = dedent(r"""
		Build Details
		-------------
		Haiku repository: @HREV@
		Buildtools repository: @BTREV@
		Haiku architecture: %(haikuArch)s
		Configure command: %(configureCommand)s
		Jam command: %(jamCommand)s
		Host machine: %(workerName)s [@BUILD_HOST@]
	"""[1:-1]) % args

	command = dedent(r"""
		set -e
		btrev=`cd ../../buildtools; git describe --tags`
		hrev=`cd ../../haiku; git describe --tags`
		buildHost=`uname -a`
		targetArch=%(targetArch)s
		repoDir=objects/haiku/$targetArch/packaging/repositories/Haiku
		version=`basename $repoDir/packages/haiku-*.hpkg | cut -d- -f2`
		targetRepoDir=haiku-repository/$targetArch/$version
		mkdir -p $targetRepoDir
		mv $repoDir/* $targetRepoDir/
		cd $targetRepoDir
		cat >ReadMe.md <<EOF
		%(readme)s
		EOF
		sed -i -e "s,@HREV@,$hrev,g" \
			-e "s,@BTREV@,$btrev,g" \
			-e "s,@BUILD_HOST@,$buildHost,g" \
			ReadMe.md
		cd ../..
		find . -type d -exec chmod 0755 {} \;
		find . -type f -exec chmod 0644 {} \;
		if [ "%(testMode)s" = "1" ]; then
			rsync --dry-run --rsh="ssh -o StrictHostKeyChecking=no" \
				--ignore-existing --progress -rp ./ \
				haikufiles@%(server)s:%(destPath)s/
		else
			rsync --rsh="ssh -o StrictHostKeyChecking=no" \
				--ignore-existing --progress -rp ./ \
				haikufiles@%(server)s:%(destPath)s/
			ssh -o StrictHostKeyChecking=no haikufiles@%(server)s \
				"cd %(destPath)s/$targetArch/ \
				 && ~/update-current-repository-link.sh $version"
		fi
	"""[1:]) % args

	return command

# render the shell command that uploads a zip with the catalog keys
@renderer
def renderUploadCatkeysCommand(props):
	args = {
		'destPath' : uploadCatkeysDestPath,
		'server' : uploadServer,
		'dryRun' : '',
	}

	command = dedent(r"""
		set -e
		cd objects/catalogs
		zip -9 catkeys.zip `find . -name \*.catkeys`
		md5sum catkeys.zip >catkeys.zip.md5
		chmod 0644 catkeys.zip*
		rsync %(dryRun)s --rsh="ssh -o StrictHostKeyChecking=no" -p \
			catkeys.zip* haikufiles@%(server)s:%(destPath)s/
	"""[1:]) % args

	return command

# render the command for moving built haiku image to a place from where it
# can be booted
@renderer
def renderMoveHaikuImageCommand(props):
	haikuImageName = props.getProperty('haikuImageName')
	return props.getProperty('moveImageCommand') % haikuImageName

###############################################################################
### BUILD FACTORIES
###############################################################################
#
#######################################
# BuildTools
#
buildtoolsFactory = BuildFactory()

# checkout buildtools sources
buildtoolsFactory.addStep(
	Git(
		name = 'Checkout buildtools',
		repourl = allRepositories['buildtools'],
		workdir = '../buildtools',
		getDescription = { 'tags' : True },
		haltOnFailure = True,
		retry = (30, 10),
		retryFetch = True,
		timeout = 1200))
# checkout newest haiku sources
buildtoolsFactory.addStep(
	Git(
		name = 'Checkout haiku',
		repourl = allRepositories['haiku'],
		workdir = '../haiku',
		getDescription = { 'tags' : True },
		haltOnFailure = True,
		alwaysUseLatest = True,
		retry = (30, 10),
		retryFetch = True,
		timeout = 1200))
# build jam
buildtoolsFactory.addStep(
	Compile(
		description = ['compiling'],
		descriptionDone = ['compiled'],
		descriptionSuffix = ['jam'],
		name = 'build jam',
		workdir='../buildtools/jam',
		timeout = 120))
# set the worker's private bin directory
buildtoolsFactory.addStep(
	master.SetProperty(
		property = 'workerBinDir',
		value = Interpolate('%(prop:builddir)s/../bin'),
		name = 'set workerBinDir',
		hideStepIf = True))
# create the worker's private bin directory and copy jam into it
buildtoolsFactory.addStep(
	ShellCommand(
		command = renderInstallJamCommand,
		description = ['installing'],
		descriptionDone = ['installed'],
		descriptionSuffix = ['jam'],
		name = 'install jam',
		workdir='../buildtools/jam',
		doStepIf = FilesAreDifferent('bin.*/jam',
			Interpolate('%(prop:workerBinDir)s/jam')),
		hideStepIf = lambda results, s: results == SKIPPED))

# drop and rebuild cross-tools for all target architectures
for targetArch in targetArchitectures:
	# set architecture property
	buildtoolsFactory.addStep(
		master.SetProperty(
			property = 'targetArch',
			value = targetArch,
			name = 'set targetArch',
			hideStepIf = True))
	# clean cross-tools dir
	crossToolsDir = '../cross-tools-%s' % targetArch
	buildtoolsFactory.addStep(
		ShellCommand(
			command = 'rm -rf "%s"' % crossToolsDir,
			description = ['deleting'],
			descriptionDone = ['deleted'],
			descriptionSuffix = [targetArch, 'tooldir'],
			name = 'delete %s tooldir' % targetArch,
			timeout = 1200))
	# create empty cross-tools dir
	buildtoolsFactory.addStep(
		ShellCommand(
			command = 'mkdir -p "%s"' % crossToolsDir,
			description = ['creating'],
			descriptionDone = ['created'],
			descriptionSuffix = [targetArch, 'tooldir'],
			name = 'create %s tooldir' % targetArch))
	# build cross tools for current architecture
	buildtoolsFactory.addStep(
		ShellCommand(
			command = renderBuildCrossToolsCommand,
			description = ['compiling'],
			descriptionDone = ['compiled'],
			descriptionSuffix = [targetArch, 'buildtools'],
			name = 'compile %s buildtools' % targetArch,
			workdir = crossToolsDir,
			timeout = 1200))

#######################################
# Haiku
#
# add build steps required for building a list of Haiku jam targets
def addStepsForBuildingHaiku(factory, haikuArch, jamTargets, **kwargs):
	haikuBranch = kwargs.get('haikuBranch', 'master')
	useLatestHaikuSource = kwargs.get('useLatestHaikuSource', False)
	generatedDir = kwargs.get('generatedDir', 'generated')
	userBuildConfig = kwargs.get('userBuildConfig', None)
	nativeBuild = kwargs.get('nativeBuild', False)
	activateGeolocationServiceKey \
		= kwargs.get('activateGeolocationServiceKey', False)

	# set haiku architecture property
	factory.addStep(
		master.SetProperty(
			property = 'haikuArch',
			value = haikuArch,
			name = 'set haikuArch',
			hideStepIf = True))
	# set nativeBuild property
	factory.addStep(
		master.SetProperty(
			property = 'nativeBuild',
			value = nativeBuild,
			name = 'set nativeBuild',
			hideStepIf = True))
	# set the worker's private bin directory
	factory.addStep(
		master.SetProperty(
			property = 'workerBinDir',
			value = Interpolate('%(prop:builddir)s/../bin'),
			name = 'set workerBinDir',
			hideStepIf = True))
	# get haiku sources
	factory.addStep(
		Git(
			name = 'Checkout Haiku',
			repourl = allRepositories['haiku'],
			workdir = '../haiku',
			getDescription = { 'tags' : True },
			branch = haikuBranch,
			alwaysUseLatest = useLatestHaikuSource,
			haltOnFailure = True,
			retry = (30, 10),
			retryFetch = True,
			timeout = 1200))
	# set UserBuildConfig on worker
	if userBuildConfig:
		factory.addStep(
			StringDownload(
				userBuildConfig,
				description = ['downloading'],
				descriptionDone = ['downloaded'],
				descriptionSuffix = ['UserBuildConfig'],
				workerdest = Interpolate(
					'%(prop:builddir)s/../haiku/build/jam/UserBuildConfig')))
	else:
		factory.addStep(
			ShellCommand(
				command = Interpolate(
					'rm -f %(prop:builddir)s/../haiku/build/jam/UserBuildConfig'
				),
				hideStepIf = True))
	# set target architectures property
	targetArchitectures \
		= hybridArchitectures.get(haikuArch, [ haikuArch ])
	factory.addStep(
		master.SetProperty(
			property = 'targetArchs',
			value = targetArchitectures,
			name = 'set targetArchs',
			hideStepIf = True))
	# set geolocation service key, if requested
	if activateGeolocationServiceKey:
		factory.addStep(
			StringDownload(
				DefaultGeolocationServiceKeyHeaderContent,
				description = ['downloading'],
				descriptionDone = ['downloaded'],
				descriptionSuffix = ['geolocation', 'service', 'key'],
				hideStepIf = True,
				workerdest = Interpolate(
					'%(prop:builddir)s/../haiku/src/kits/shared/DefaultGeolocationServiceKey.h')))
	if not nativeBuild:
		# make sure the buildtools sources are available, too
		factory.addStep(
			Git(
				name = 'Checkout buildtools',
				repourl = allRepositories['buildtools'],
				workdir = '../buildtools',
				getDescription = { 'tags' : True },
				branch = haikuBranch,
				alwaysUseLatest = True,
				haltOnFailure = True,
				doStepIf = PathIsMissing('../buildtools/jam/README'),
				hideStepIf = lambda results, s: results == SKIPPED,
				retry = (30, 10),
				retryFetch = True,
				timeout = 1200))
		# drop cross tools commands (forcing a rebuild of the cross tools) if
		# the script that builds them has been changed
		for targetArch in targetArchitectures:
			if targetArch == 'x86_gcc2':
				script = 'build_cross_tools'
			else:
				script = 'build_cross_tools_gcc4'
			factory.addStep(
				ShellCommand(
					command = dedent("""
						if ! cmp -s ../haiku/build/scripts/%(script)s \
							../trigger-files/%(haikuBranch)s/%(script)s; then
							rm -f ../cross-tools-*/cross-tools-*/bin/*
							mkdir -p ../trigger-files/%(haikuBranch)s
							cp ../haiku/build/scripts/%(script)s \
								../trigger-files/%(haikuBranch)s/
						fi
						"""[1:]) % {
							'haikuBranch' : haikuBranch,
							'script' : script,
						},
					description = ['check', script],
					name = 'check ' + script,
					workdir = Property('builddir'),
					hideStepIf = True))
		# build cross-tools for all target architectures if needed (may be more
		# than one set if the current haiku architecture is a hybrid)
		for targetArch in targetArchitectures:
			# set target architecture property
			factory.addStep(
				master.SetProperty(
					property = 'targetArch',
					value = targetArch,
					description = ['set', 'targetArch'],
					name = 'set targetArch',
					hideStepIf = True))
			# build cross tools for current target architecture, if needed
			crossToolsDir = '../cross-tools-%s' % targetArch
			toolBinDir = crossToolsDir + '/cross-tools-%s/bin' % targetArch
			machineTriple = machineTriples[targetArch]
			factory.addStep(
				ShellCommand(
					command = renderBuildCrossToolsCommand,
					description = ['compiling'],
					descriptionDone = ['compiled'],
					descriptionSuffix = [targetArch, 'buildtools'],
					name = 'compile %s tools' % targetArch,
					workdir = crossToolsDir,
					haltOnFailure = True,
					doStepIf = PathIsMissing(toolBinDir + '/%s-gcc'
											 % machineTriple),
					hideStepIf = lambda results, s: results == SKIPPED,
					timeout = 1200))
	# clean workdir
	factory.addStep(
		ShellCommand(
			command = 'rm -rf "%s"' % generatedDir,
			description = ['deleting'],
			descriptionDone = ['deleted'],
			descriptionSuffix = ['workdir'],
			name = 'delete workdir',
			workdir = Property('builddir'),
			timeout = 1200))
	# create empty workdir
	factory.addStep(
		ShellCommand(
			command = 'mkdir -p "%s"' % generatedDir,
			description = ['creating'],
			descriptionDone = ['created'],
			descriptionSuffix = ['workdir'],
			name = 'create workdir',
			workdir = Property('builddir'),
			haltOnFailure = True))
	# configure build
	factory.addStep(
		ShellCommand(
			command = renderConfigureBuildCommand,
			description = ['configuring'],
			descriptionDone = ['configure'],
			name = 'configure build',
			haltOnFailure = True,
			workdir = generatedDir))
	# create and flush download dir
	factory.addStep(
		ShellCommand(
			command = renderSetupDownloadDirCommand,
			description = ['setting'],
			descriptionDone = ['set'],
			descriptionSuffix = ['download', 'dir'],
			name = 'setup download dir',
			haltOnFailure = True))
	# build jam
	factory.addStep(
		Compile(
			description = ['compiling'],
			descriptionDone = ['compiled'],
			descriptionSuffix = ['jam'],
			name = 'build jam',
			workdir='../buildtools/jam',
			doStepIf = PathIsMissing(Interpolate('%(prop:workerBinDir)s/jam')),
			hideStepIf = lambda results, s: results == SKIPPED,
			timeout = 120))
	# create the worker's private bin directory and copy jam into it
	factory.addStep(
		ShellCommand(
			command = renderInstallJamCommand,
			description = ['installing'],
			descriptionDone = ['installed'],
			descriptionSuffix = ['jam'],
			name = 'install jam',
			workdir='../buildtools/jam',
			doStepIf = PathIsMissing(Interpolate('%(prop:workerBinDir)s/jam')),
			hideStepIf = lambda results, s: results == SKIPPED))
	# build all given jam targets
	for jamTarget in jamTargets:
		# set current jam target property
		factory.addStep(
			master.SetProperty(
				property = 'jamTarget',
				value = jamTarget,
				description = ['set'],
				descriptionDone = ['set'],
				descriptionSuffix = ['jamTarget'],
				name = 'set jamTarget',
				hideStepIf = True))
		# build current jam target
		filteredJamTargetElements = [
			# Skip everything starting with '-s', in order to
			# simplify the view. Additionally, HTML-escape the
			# text in order to preserve something like
			# <repository>Haiku in HTML views.
			cgi.escape(target) for target in jamTarget.split()
			if not target.startswith('-s')
		]
		factory.addStep(
			ShellCommand(
				command = renderJamCommand,
				description = ['jam'],
				descriptionDone = ['jam'],
				descriptionSuffix = filteredJamTargetElements,
				name = 'jam ' + ' '.join(filteredJamTargetElements),
				haltOnFailure = True,
				workdir = generatedDir,
				env = renderJamEnvironment,
				timeout = 3600))

generatedDir = 'generated'

# create build factories for building all Haiku architectures, each in its own
# builder
haikuFactories = {}
for haikuArch in haikuArchitectures:
	fHaiku = BuildFactory()
	addStepsForBuildingHaiku(fHaiku, haikuArch, jamTargets[haikuArch])
	haikuFactories[haikuArch] = fHaiku

# factories for building debug builds of Haiku
haikuDebugFactories = {}
for haikuArch in haikuArchitectures:
	fHaiku = BuildFactory()
	addStepsForBuildingHaiku(fHaiku, haikuArch, jamDebugTargets[haikuArch])
	haikuDebugFactories[haikuArch] = fHaiku

# factories for building and uploading haiku repositories
haikuRepositoriesFactories = {}
for haikuArch in repositoriesJamTargets.keys():
	fHaiku = BuildFactory()
	addStepsForBuildingHaiku(fHaiku, haikuArch,
							 repositoriesJamTargets[haikuArch])
	fHaiku.addStep(
		ShellCommand(
			command = renderUploadRepositoryCommand,
			description = ['upload'],
			descriptionDone = ['uploaded'],
			descriptionSuffix = ['repository'],
			name = 'upload repository',
			timeout = 3600,
			workdir = generatedDir))
	haikuRepositoriesFactories[haikuArch] = fHaiku

# factories for building and uploading nightly images
haikuNightliesFactories = {}
for haikuArch in nightliesJamTargets.keys():
	fHaiku = BuildFactory()
	addStepsForBuildingHaiku(fHaiku, haikuArch, nightliesJamTargets[haikuArch],
							 activateGeolocationServiceKey = True)
	if haikuArch == 'x86_gcc2_hybrid':
		fHaiku.addStep(
			ShellCommand(
				command = renderUploadCatkeysCommand,
				description = ['upload'],
				descriptionDone = ['uploaded'],
				descriptionSuffix = ['catkeys'],
				name = 'upload catkeys',
				timeout = 300,
				haltOnFailure = False,
				workdir = generatedDir))
	fHaiku.addStep(
		ShellCommand(
			command = renderUploadNightliesCommand,
			description = ['upload'],
			descriptionDone = ['uploaded'],
			descriptionSuffix = ['nightlies'],
			name = 'upload nightlies',
			timeout = 3600,
			workdir = generatedDir))
	haikuNightliesFactories[haikuArch] = fHaiku

# factories for building Haiku natively
haikuNativeFactories = {}
for haikuArch in haikuArchitectures:
	fHaiku = BuildFactory()
	addStepsForBuildingHaiku(fHaiku, haikuArch, nativeJamTargets,
							 nativeBuild = True)
	haikuNativeFactories[haikuArch] = fHaiku

# factories for building a target Haiku image for each haikuports architecture
# branch
haikuportsHostFactories = {}
for haikuport in haikuports:
	fHaikuportsHost = BuildFactory()
	userBuildConfig = dedent("""
		DefineBuildProfile haikuports : image : "haikuports.raw" ;
		AddHaikuImagePackages Development Git OpenSSL buildbot_worker ;
		HAIKU_IMAGE_SIZE = 4000 ;
		HAIKU_PACKAGE_COMPRESSION_LEVEL = 1 ;
	"""[1:]) % { 'branch': haikuport['branch'] }
	addStepsForBuildingHaiku(fHaikuportsHost, haikuport['haikuArch'],
							 [ '@haikuports' ],
							 haikuBranch = haikuport['haikuBranch'],
							 useLatestHaikuSource = True,
							 userBuildConfig = userBuildConfig)
	fHaikuportsHost.addStep(
		master.SetProperty(
			property = 'haikuImageName',
			value = 'haikuports.raw',
			description = ['set'],
			descriptionDone = ['set'],
			descriptionSuffix = ['haikuImageName'],
			name = 'set haikuImageName',
			hideStepIf = True))
	fHaikuportsHost.addStep(
		ShellCommand(
			command = renderMoveHaikuImageCommand,
			description = ['moving'],
			descriptionDone = ['moved'],
			descriptionSuffix = ['image'],
			name = 'moving image',
			haltOnFailure = True,
			workdir = generatedDir))
	fHaikuportsHost.addStep(
		Trigger(
			schedulerNames = [ 'trigger-haikuports-%s' % haikuport['branch'] ],
			waitForFinish = True,
			updateSourceStamp = True,
			name = 'build on Haiku',
			haltOnFailure = True))
	haikuportsHostFactories[haikuport['branch']] = fHaikuportsHost

# factories for the actual haikuports package trees build for each haikuports
# architecture branch
haikuportsTargetFactories = {}
for haikuport in haikuports:
	fHaikuportsTarget = BuildFactory()
	# set haiku architecture property
	fHaikuportsTarget.addStep(
		master.SetProperty(
			property = 'haikuArch',
			value = haikuport['haikuArch'],
			description = ['set'],
			descriptionDone = ['set'],
			descriptionSuffix = ['haikuArch'],
			name = 'set haikuArch',
			hideStepIf = True))
	# get haikuports tree
	fHaikuportsTarget.addStep(
		Git(
			name = 'Checkout Haikuports',
			repourl = allRepositories['haikuports'],
			workdir = '../haikuports',
			branch = haikuport['branch'],
			haltOnFailure = True,
			retry = (30, 10),
			retryFetch = True,
			timeout = 1200))
	haikuportsConfig = Interpolate(dedent("""
		TREE_PATH='%(prop:builddir)s/../haikuports'
		OUTPUT_DIRECTORY='%(prop:builddir)s/haikuports.%(prop:haikuArch)s'
		PACKAGER='Haiku buildmaster <buildmaster@haiku-os.org>'
	"""[1:]))
	fHaikuportsTarget.addStep(
		StringDownload(
			haikuportsConfig,
			description = ['downloading'],
			descriptionDone = ['downloaded'],
			descriptionSuffix = ['haikuports.conf'],
			workerdest = Interpolate(
				'%(prop:builddir)s/haikuports.%(prop:haikuArch)s/haikuports.conf'
			)))
	# get latest haikuporter sources
	fHaikuportsTarget.addStep(
		Git(
			name = 'Checkout Haikuporter',
			repourl = allRepositories['haikuporter'],
			workdir = '../haikuporter',
			branch = haikuport['branch'],
			alwaysUseLatest = True,
			haltOnFailure = True,
			retry = (30, 10),
			retryFetch = True,
			timeout = 1200))
	haikuportsTargetFactories[haikuport['branch']] = fHaikuportsTarget

# factories for building a target Haiku image for each bootstrap
bootstrapHostFactories = {}
for bootstrap in bootstraps:
	fBootstrapHost = BuildFactory()
	# get haikuports tree
	fBootstrapHost.addStep(
		Git(
			name = 'Checkout Haikuports',
			repourl = allRepositories['haikuports'],
			workdir = '../haikuports',
			branch = bootstrap['haikuportsBranch'],
			alwaysUseLatest = True,
			haltOnFailure = True,
			retry = (30, 10),
			retryFetch = True,
			timeout = 1200))
	# get haikuports.cross tree
	fBootstrapHost.addStep(
		Git(
			name = 'Checkout Haikuports-cross',
			repourl = allRepositories['haikuports.cross'],
			workdir = '../haikuports.cross',
			alwaysUseLatest = True,
			haltOnFailure = True,
			retry = (30, 10),
			retryFetch = True,
			timeout = 1200))
	# get haikuporter sources
	fBootstrapHost.addStep(
		Git(
			name = 'Checkout Haikuporter',
			repourl = allRepositories['haikuporter'],
			workdir = '../haikuporter',
			alwaysUseLatest = True,
			haltOnFailure = True,
			retry = (30, 10),
			retryFetch = True,
			timeout = 1200))
	# set configure args for bootstrap
	fBootstrapHost.addStep(
		master.SetProperty(
			property = 'configureForBootstrap',
			value = True,
			description = ['set'],
			descriptionDone = ['set'],
			descriptionSuffix = ['configureForBootstrap'],
			name = 'set configureForBootstrap',
			hideStepIf = True))
	# build Haiku image
	userBuildConfig = dedent("""
		AddHaikuImagePackages Development Git OpenSSL buildbot_worker ;
		HAIKU_PACKAGE_COMPRESSION_LEVEL = 1 ;
	"""[1:]) % { 'branch': haikuport['branch'] }
# 	addStepsForBuildingHaiku(fBootstrapHost, bootstrap['haikuArch'],
# 							 [ '@bootstrap-raw' ],
# 							 haikuBranch = bootstrap['haikuBranch'],
# 							 useLatestHaikuSource = True,
# 							 userBuildConfig = userBuildConfig)
	fBootstrapHost.addStep(
		master.SetProperty(
			property = 'haikuImageName',
			value = 'haiku-bootstrap.image',
			description = ['set'],
			descriptionDone = ['set'],
			descriptionSuffix = ['haikuImageName'],
			name = 'set haikuImageName',
			hideStepIf = True))
	fBootstrapHost.addStep(
		ShellCommand(
			command = renderStartTargetVmCommand,
			description = ['starting'],
			descriptionDone = ['started'],
			descriptionSuffix = ['target', 'VM'],
			name = 'starting target VM',
			haltOnFailure = True,
			workdir = generatedDir))
	fBootstrapHost.addStep(
		Trigger(
			schedulerNames = [
				'trigger-bootstrap-%s' % bootstrap['haikuArch']
			],
			waitForFinish = True,
			updateSourceStamp = True,
			name = 'build on Haiku',
			haltOnFailure = True))
	bootstrapHostFactories[haikuport['haikuArch']] = fBootstrapHost

# factories for the actual bootstrap package trees build
bootstrapTargetFactories = {}
for bootstrap in bootstraps:
	fBootstrapTarget = BuildFactory()
	# set haiku architecture property
	fBootstrapTarget.addStep(
		master.SetProperty(
			property = 'haikuArch',
			value = bootstrap['haikuArch'],
			description = ['set'],
			descriptionDone = ['set'],
			descriptionSuffix = ['haikuArch'],
			name = 'set haikuArch',
			hideStepIf = True))
	# write haikuports.conf
	haikuportsConfig = dedent("""
		TREE_PATH="/boot/home/haikuports"
		PACKAGER='Haiku buildmaster <buildmaster@haiku-os.org>'
		TARGET_ARCHITECTURE="%s"
		SECONDARY_TARGET_ARCHITECTURES=""
	"""[1:])
	fBootstrapTarget.addStep(
		StringDownload(
			haikuportsConfig,
			description = ['downloading'],
			descriptionDone = ['downloaded'],
			descriptionSuffix = ['haikuports.conf'],
			workerdest = '/boot/home/haikuports/haikuports.conf'))
	# execute the bootstrap package build
	fBootstrapTarget.addStep(
		ShellCommand(
			command = renderHaikuportsDoBootstrapCommand,
			description = ['bootstrapping'],
			descriptionDone = ['bootstrap', 'done'],
			name = 'bootstrapping',
			haltOnFailure = True,
			workdir = '/boot/home/haikuports/',
			env = renderJamEnvironment,
			timeout = 3600))
	bootstrapTargetFactories[bootstrap['haikuArch']] = fBootstrapTarget

###############################################################################
### BUILDERS
###############################################################################
#
c['builders'] = []

# Add one builder per worker, so buildtools for all architectures get built
# on every worker.
crossBuildtoolsMasterBuilders = []
for workerName in workersForTask(allWorkers, "haiku-master"):
	crossBuildtoolsMasterBuilders.append(
		BuilderConfig(
			name = 'buildtools-master-' + workerName,
			workernames = [workerName],
			canStartBuild = enforceChosenWorker,
			tags = ['buildtools.master'],
			factory = buildtoolsFactory))
c['builders'] += crossBuildtoolsMasterBuilders

haikuMasterBuilders = []
haikuDebugMasterBuilders = []
haikuMasterNativeBuilders = []
haikuRepositoriesBuilders = []
haikuNightliesBuilders = []
haikuportsHostBuilders = {}
haikuportsTargetBuilders = {}
bootstrapHostBuilders = {}
bootstrapTargetBuilders = {}

## Add builders for haiku repositories, running for each revision:
#for haikuArch in repositoriesJamTargets.keys():
#	haikuRepositoriesBuilders.append(
#		BuilderConfig(
#			name = 'haiku-repository-%s' % haikuArch,
#			canStartBuild = enforceChosenWorker,
#			tags = ['haiku.master'],
#			workernames = workersForTask(allWorkers, "repo"),
#			factory = haikuRepositoriesFactories[haikuArch]))

# Add builders for nightly images:
#for haikuArch in nightliesJamTargets.keys():
#	haikuNightliesBuilders.append(
#		BuilderConfig(
#			name = 'haiku-nightlies-%s' % haikuArch,
#			canStartBuild = enforceChosenWorker,
#			tags = ['haiku.master', 'nightly'],
#			workernames = workersForTask(allWorkers, "nightly"),
#			factory = haikuNightliesFactories[haikuArch]))

# Add builders for each Haiku architecture, running once (using any
# available worker).
for haikuArch in haikuArchitectures:
	haikuMasterBuilders.append(
		BuilderConfig(
			name = 'haiku-master-%s' % haikuArch,
			canStartBuild = enforceChosenWorker,
			tags = ['haiku.master'],
			workernames = workersForTask(allWorkers, "haiku-master"),
			factory = haikuFactories[haikuArch]))
	haikuDebugMasterBuilders.append(
		BuilderConfig(
			name = 'haiku-master-%s-debug' % haikuArch,
			canStartBuild = enforceChosenWorker,
			tags = ['haiku.master'],
			workernames = workersForTask(allWorkers, "haiku-master"),
			factory = haikuDebugFactories[haikuArch]))

# Add builders for native Haiku builds:
for haikuArch in haikuArchitectures:
	workerNames = []
	for workerName in nativeHaikuWorkerNames:
		worker = workersByName[workerName]
		if worker.properties.getProperty('workerHaikuArch', '') == haikuArch:
			workerNames.append(workerName)
	# only add a builder for an architecture for which there is at least one
	# native worker
	if workerNames:
		haikuMasterNativeBuilders.append(
			BuilderConfig(
				name = 'haiku-master-native-%s' % haikuArch,
				canStartBuild = enforceChosenWorker,
				tags = ['haiku.master', 'native'],
				workernames = workerNames,
				factory = haikuNativeFactories[haikuArch]))


# XXX: Bootstrap never works reliabily :-|
# Add host builders for each bootstrap.
#for bootstrap in bootstraps:
#	if bootstrapWorkerNames.keys():
#		haikuArch = bootstrap['haikuArch']
#		# The host builder builds the haiku bootstrap image and then triggers
#		# the corresponding bootstrap package build running on that image.
#		bootstrapHostBuilders[haikuArch] = BuilderConfig(
#			name = 'bootstrap-%s-master-host' % haikuArch,
#			canStartBuild = enforceChosenWorker,
#			tags = ['bootstrap'],
#			workernames = workersForTask(allWorkers, "bootstrap"),
#			factory = bootstrapHostFactories[haikuArch])
#		# The target builder runs the actual bootstrap package build on Haiku.
#		bootstrapTargetBuilders[haikuArch] = BuilderConfig(
#			name = 'bootstrap-%s-master-target' % haikuArch,
#			canStartBuild = enforceChosenWorker,
#			tags = ['bootstrap'],
#			workernames = workersForTask(allWorkers, "bootstrap"),
#			factory = bootstrapTargetFactories[haikuArch])

c['builders'] += haikuMasterBuilders
c['builders'] += haikuDebugMasterBuilders
c['builders'] += haikuMasterNativeBuilders
c['builders'] += haikuRepositoriesBuilders
c['builders'] += haikuNightliesBuilders
c['builders'] += haikuportsHostBuilders.values()
c['builders'] += haikuportsTargetBuilders.values()
c['builders'] += bootstrapHostBuilders.values()
c['builders'] += bootstrapTargetBuilders.values()

###############################################################################
### SCHEDULERS
###############################################################################
#
c['schedulers'] = []

if crossBuildtoolsMasterBuilders:
	# A scheduler for building buildtools.master for all architectures.
	c['schedulers'].append(
		basic.SingleBranchScheduler(
			name = 'update-buildtools-master',
			treeStableTimer = 300,
			change_filter = ChangeFilter(
				project = 'buildtools',
				branch = 'master'),
			builderNames = [ b.name for b in crossBuildtoolsMasterBuilders ]))

if haikuMasterBuilders or haikuMasterNativeBuilders:
	# A scheduler for building (a set of jam targets of) haiku.master for all
	# architectures.
	c['schedulers'].append(
		basic.SingleBranchScheduler(
			name = 'update-haiku-master',
			treeStableTimer = 300,
			change_filter = ChangeFilter(
				project = 'haiku',
				branch = 'master'),
			builderNames = [ b.name for b in haikuMasterBuilders ] \
							+ [ b.name for b in haikuMasterNativeBuilders ]))

if haikuDebugMasterBuilders:
	# A scheduler for building debug versions of (a set of jam targets of)
	# haiku.master for all architectures once per week.
	c['schedulers'].append(
		timed.Nightly(
			name = 'weekly-haiku-master-debug',
			change_filter = ChangeFilter(
				project = 'haiku',
				branch = 'master'),
			branch = 'master',
			dayOfWeek = 6,
			hour = 3,
			minute = 0,
			builderNames = [ b.name for b in haikuDebugMasterBuilders ]))

if haikuRepositoriesBuilders:
	# A scheduler for building and uploading haiku repositories.
	c['schedulers'].append(
		basic.SingleBranchScheduler(
			name = 'update-haiku-repositories-master',
			treeStableTimer = 300,
			change_filter = ChangeFilter(
				project = 'haiku',
				branch = 'master'),
			builderNames = [ b.name for b in haikuRepositoriesBuilders ]))

if haikuNightliesBuilders:
	# A scheduler for building and uploading nightly images, once per day.
	c['schedulers'].append(
		timed.Nightly(
			name = 'nightly-haiku-master',
			change_filter = ChangeFilter(
				project = 'haiku',
				branch = 'master'),
			branch = 'master',
			hour = 2,
			minute = 0,
			builderNames = [ b.name for b in haikuNightliesBuilders ]))

## A scheduler for building haikuports trees for all haikuports architecture
## branches.
#for haikuport in haikuports:
#	branch = haikuport['branch']
#	# A scheduler tracking haikuports architecture branches and doing the
#	# host part of the build.
#	if branch in haikuportsHostBuilders:
#		c['schedulers'].append(
#			basic.SingleBranchScheduler(
#				name = 'update-haikuports-%s' % branch,
#				treeStableTimer = 300,
#				change_filter = ChangeFilter(
#					project = 'haikuports',
#					branch = branch),
#				builderNames = [ haikuportsHostBuilders[branch].name ]))
#	# A triggerable scheduler that executes the Haiku part of the build.
#	if branch in haikuportsTargetBuilders:
#		c['schedulers'].append(
#			triggerable.Triggerable(
#				name = 'trigger-haikuports-%s' % branch,
#				builderNames = [ haikuportsTargetBuilders[branch].name ]))

## A scheduler for doing bootstraps regularly.
#for bootstrap in bootstraps:
#	haikuArch = bootstrap['haikuArch']
#	# A scheduler that initiates bootstrap builds when they are due.
#	if haikuArch in bootstrapHostBuilders:
#		c['schedulers'].append(
#			timed.Nightly(
#				name = 'bootstrap-%s-master' % haikuArch,
#				change_filter = ChangeFilter(
#					project = 'haiku',
#					branch = 'master'),
#				branch = 'master',
#				dayOfWeek = bootstrap['dayOfWeek'],
#				hour = bootstrap['hour'],
#				builderNames = [ bootstrapHostBuilders[haikuArch].name ]))
#	# A triggerable scheduler that executes the Haiku part of the build.
#	if haikuArch in bootstrapTargetBuilders:
#		c['schedulers'].append(
#			triggerable.Triggerable(
#				name = 'trigger-bootstrap-%s' % haikuArch,
#				builderNames = [ bootstrapTargetBuilders[haikuArch].name ]))

# TODO: FIX?
# A scheduler for forcing individual builds of all builders.
#c['schedulers'].append(
#	forcesched.ForceScheduler(
#		name = 'force',
#		builderNames = [ b.name for b in c['builders'] ],
#
#		# will generate nothing in the form, but revision, repository,
#		# and project are needed by buildbot scheduling system so we
#		# need to pass a value ("")
#		revision = forcesched.FixedParameter(name = "revision",
#											 default = ""),
#		repository = forcesched.FixedParameter(name = "repository",
#											   default = ""),
#		project = forcesched.FixedParameter(name = "project",
#											default = ""),
#
#		# A completely customized property list.  The name of the
#		# property is the name of the parameter
#		properties = [
#			forcesched.BuildworkerChoiceParameter(),
#		]))
